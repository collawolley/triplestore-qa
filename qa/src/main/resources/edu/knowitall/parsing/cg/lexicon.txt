# ruleName syntactic-pattern := semantic-type semantic-pattern

fullPatternSubj @whowhat (<rel>:@reverb) (<arg>:@np)      := unary $x : ($x, $rel, $arg)
fullPatternDobj @whowhat @aux (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $rel, $x)
fullPatternWhereIn @where (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel in, $x)
fullPatternWhenIn @when (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel in, $x)
fullPatternWhenOn @when (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel on, $x)
fullPatternTypeDobj @whatwhich (<type>:@np) @aux (<arg>:@np) (<rel>:@reverb) := unary $x : ($x, is a, $type) ($arg, $rel, $x)
fullPatternTypeSubj @whatwhich (<type>:@np) (<rel>:@reverb) (<arg>:@np) := unary $x : ($x, is a, $type) ($x, $rel, $arg)
fullPatternProperty @what @be @det (<rel>:@np) @of (<arg>:@np) := unary $x : ($arg, $rel, $x) 

npArg (<arg>:@np) := argument $arg
type (@be (?:@det|@some))? (@type @of)? (<type>:@nounMod* @noun+) := unary $x : ($x, is a, $type)
reverbBinary (<rel>:@reverb) := binary $x, $y : ($x, $rel, $y)
adjPrepBinary @be? (<rel>:@adj @prep) := binary $x, $y : ($x, $rel, $y)
whIdentity @wh := .
auxIdentity @aux := .
punctIdentity @punct := .
relMarkerIdentity @relMarker := .
conjIdentity @conj := .
