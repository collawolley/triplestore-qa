# ruleName syntactic-pattern := semantic-type semantic-pattern

fullPatternSubj @whowhat (<rel>:@reverb) (<arg>:@np)      := unary $x : ($x, $rel, $arg)
fullPatternDobj @whowhat @aux (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $rel, $x)

fullPatternWhereIn @where (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel in, $x)
fullPatternWhereIs @where (<aux>:@aux) (<arg>:@np) := unary $x : ($arg, $aux in, $x)

fullPatternWhenIn @when (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel in, $x)
fullPatternWhenOn @when (<aux>:@aux) (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $aux $rel on, $x)
fullPatternWhenBeIn @when @be (<arg>:@np) := unary $x : ($arg, be in, $x)
fullPatternWhenBeOn @when @be (<arg>:@np) := unary $x : ($arg, be on, $x)

fullPatternTypeDobj (@whatwhich|@howmany) (<type>:@np) @aux (<arg>:@np) (<rel>:@reverb) := unary $x : ($x, instance of, $type) ($arg, $rel, $x)
fullPatternTypeSubj (@whatwhich|@howmany) (<type>:@np) (<rel>:@reverb) (<arg>:@np) := unary $x : ($x, instance of, $type) ($x, $rel, $arg)
fullPatternProperty @what @be @det (<rel>:@np) @of (<arg>:@np) := unary $x : ($arg, $rel, $x) 
fullPatternDefn @whowhat @be (<arg>:@np) := unary $x : ($arg, instance of, $x)
fullPatternRelType @whatwhich (<type>:@np) @aux (<arg>:@np) (<rel>:@reverb) := unary $x : ($arg, $rel $type, $x)
fullPatternCop @whatwhich (<rel>:@np) @be (<arg>:@np) := unary $x : ($arg, $rel, $x)
fullPatternHaveProp @wh (<rel>:@np) @aux (<arg>:@np) @have := unary $x : ($arg, $rel, $x)
fullPatternPoss @wh @be (<arg>:@np) @pos (<rel>:@np) := unary $x : ($arg, $rel, $x)

npArg (<arg>:@np) := argument $arg
npTitle @the @commonNoun (<arg>:@noun) := argument $arg
npOfArg (<arg>:@np @of @np) := argument $arg
adjArg (<arg>:@adj+) := argument $arg
type (@be (?:@det|@quant))? @quant? (@type @of)? (<type>:@nounMod* @noun+) := unary $x : ($x, instance of, $type)
reverbBinary (<rel>:@reverb) := binary $x, $y : ($x, $rel, $y)
reverbBinaryNoPrep (<rel>:@reverbNoPrep) := binary $x, $y : ($x, $rel, $y)
nounPrepBinary (<rel>:@np @prep) := binary $x, $y : ($x, $rel, $y)
adjPrepBinary @be? (<rel>:@adj @prep) := binary $x, $y : ($x, $rel, $y)
possessiveUnary (<arg>:@np) @pos (<rel>:@np) := unary $x : ($x, $rel, $arg)
beInstanceOf (<rel>:@be) := binary $x, $y : ($x, instance of, $y)

finalNounHack @aux (<arg>:@np) (<rel>:<pos='NN'>) @punct := unary $x : ($arg, $rel, $x)

whIdentity @wh := identity
auxIdentity @aux := identity
punctIdentity @punct := identity
relMarkerIdentity @relMarker := identity 
conjIdentity @conj := identity
isThere @be @there := identity
ignoreTypesIdentity @ignoreTypes := identity
there @there := identity
quantIdentity @quant := identity

#howModWith @how := mod with
#howModFrom @how := mod from
#whereModIn @where := mod in
#whenModIn @when := mod in
#whenModOn @when := mod on
#prepMod (<p>:@prep) := mod $p
